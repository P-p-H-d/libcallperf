/* LIBCALLPERF
   Copyright 2018 Patrick Pelissier
	
   The LIBCALLPERF Library is free software; you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation; either version 3 of the License, or (at your
   option) any later version.
 	
   The LIBCALLPERF Library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
   License for more details.
 	
   You should have received a copy of the GNU Lesser General Public License
   along with the LIBCALLPERF Library; see the file COPYING.LESSER.  If not, see
   http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA. */

#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <unistd.h>

#include "m-string.h"
#include "m-dict.h"

#include "libcallperf.h"

#define MAX_FILENAME 1024
#define MAX_ARG 16

#define SCRIPT_PATTERN   "/tmp/libcallperf-script-%d.sh"
#define CONTINUE_PATTERN "/tmp/libcallperf-continue-%d.txt"
#define REPORT_PATTERN   "/tmp/libcallperf-report-%d.txt"

/* Internal data */
static pid_t my_pid;
static pid_t child_g;
static char  filename_continue[MAX_FILENAME];
static char  filename_script[MAX_FILENAME];
static char  filename_report[MAX_FILENAME];

BOUNDED_STRING_DEF(string64, 63)
DICT_DEF2(perf_report,
	  string64_t, BOUNDED_STRING_OPLIST(string64),
	  double, M_DEFAULT_OPLIST)

struct libcallperf_report_s
{
  perf_report_t dict;
};

static void libcallperf_cleanup(void)
{
  unlink(filename_script);
  unlink(filename_report);
  unlink(filename_continue);
}

int libcallperf_start(char *what)
{
  FILE *f;

  my_pid = getpid();
  // Generate names
  snprintf(filename_script, sizeof filename_script, SCRIPT_PATTERN, (int)my_pid);
  snprintf(filename_continue, sizeof filename_continue, CONTINUE_PATTERN, (int)my_pid);
  snprintf(filename_report, sizeof filename_report, REPORT_PATTERN, (int)my_pid);

  // Create a shell script (a compiled program will be faster)
  f = fopen(filename_script, "w");
  if (!f) return -1;
  fprintf(f, 
	  "#!/bin/sh\n"
	  "echo 1 > %s\n"
	  "while test -f %s ; do true ; done\n"
	  "exit 0", filename_continue, filename_continue);
  fclose (f);

  // Remove continue file (in case of)
  unlink(filename_continue);

  // Create perf process
  pid_t pid = fork();
  if (pid == -1) {
    return -3;
  }
  if (pid == 0) {
    // Redirect stdout to the report file
    freopen(filename_report, "a+", stderr); 
    // Give arguments to perf command
    char *args[MAX_ARG];
    int n = 0;
    args[n++] = "/usr/bin/perf";
    args[n++] = "stat";
    args[n++] = "-x/";
    if (what != NULL) {
      args[n++] = what;
    }
    args[n++] = "-p";
    char pid_str[64];
    snprintf(pid_str, sizeof(pid_str), "%d", (int)my_pid);
    args[n++] = pid_str;
    args[n++] = "/bin/sh";
    args[n++] = filename_script;
    args[n++] = NULL;
    args[n] = "LANG=C";
    args[n+1] = NULL;
    assert (n+1 < MAX_ARG);
    execve("/usr/bin/perf", args, &args[n]);
    abort();
  }

  // Save child PID
  child_g = pid;

  // Wait for the creation of the continue file
  struct stat buf;
  while (stat (filename_continue, &buf) != 0);
  
  return 0;
}

struct libcallperf_report_s *libcallperf_stop(void)
{
  FILE *f;

  // Remove continue file
  int ret = unlink(filename_continue);
  if (ret != 0) {
    libcallperf_cleanup();
    return NULL;
  }
  
  // Wait for terminaison of perf command
  int status;
  (void)waitpid(child_g, &status, 0);
  if (status != 0) {
    libcallperf_cleanup();
    return NULL;
  }

  // Open the report file generated by perf
  f = fopen(filename_report, "r");
  if (!f) {
    libcallperf_cleanup();
    return NULL;
  }
  
  // Create struct to get the result
  struct libcallperf_report_s *p = malloc(sizeof(struct libcallperf_report_s));
  if (!p) {
    libcallperf_cleanup();
    return NULL;
  }
  perf_report_init(p->dict);
  
  //parse /tmp/libcallperf-report-$$.txt into a dictionnary string-->integer
  while (!feof(f) && !ferror(f)) {
    char line[1024], *end, *name;
    if (fgets(line, sizeof line -1, f) == NULL) 
      break;
    double val = strtod(line, &end);
    if (*end != '/')
      continue;
    end++;
    if (*end != '/')
      continue;
    name = end+1;
    end = strchr(name, '/');
    if (!end)
      continue;
    *end = 0;
    perf_report_set_at(p->dict, BOUNDED_STRING_CTE(string64, name), val);
  }
  
  // Cleanup
  libcallperf_cleanup();
  return p;
}

double libcallperf_get (const struct libcallperf_report_s *p, const char name[])
{
  double *ptr = perf_report_get(p->dict, BOUNDED_STRING_CTE(string64, name));
  return ptr == NULL ? NAN : *ptr;
}

void libcallperf_print(FILE *stream, const struct libcallperf_report_s *p)
{
  perf_report_it_t it;
  for(perf_report_it(it, p->dict); !perf_report_end_p(it); perf_report_next(it)) {
    const struct perf_report_pair_s *item = perf_report_cref(it);
    fprintf(stream, "%s=%f\n",
	    string64_get_cstr(item->key), item->value);
  }
  
}

void libcallperf_free (struct libcallperf_report_s *p)
{
  perf_report_clear(p->dict);
  free(p);
}

